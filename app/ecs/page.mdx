import { MdxLayout } from "../../components/MdxLayout";
import { ImageFull } from "../../components/ImageFull";
import { Sandbox } from "../../components/Sandbox";

import { styles as styles1 } from "./sandpackFiles/1/styles.ts";
import indexHtml1 from "!!raw-loader!./sandpackFiles/1/index.html";
import indexTs1 from "!!raw-loader!./sandpackFiles/1/index.ts";
import engineTs1 from "!!raw-loader!./sandpackFiles/1/src/engine.ts";
import renderSystemTs1 from "!!raw-loader!./sandpackFiles/1/src/renderSystem.ts";
import entitiesTs1 from "!!raw-loader!./sandpackFiles/1/src/entities.ts";

import { styles as styles2 } from "./sandpackFiles/2/styles.ts";
import indexHtml2 from "!!raw-loader!./sandpackFiles/2/index.html";
import indexTs2 from "!!raw-loader!./sandpackFiles/2/index.ts";
import engineTs2 from "!!raw-loader!./sandpackFiles/2/src/engine.ts";
import renderSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/renderSystem.ts";
import inputSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/inputSystem.ts";
import entitiesTs2 from "!!raw-loader!./sandpackFiles/2/src/entities.ts";

import engineTs3 from "!!raw-loader!./sandpackFiles/3/src/engine.ts";
import renderSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/renderSystem.ts";
import inputSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/inputSystem.ts";
import momentumSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/momentumSystem.ts";
import entitiesTs3 from "!!raw-loader!./sandpackFiles/3/src/entities.ts";

import indexHtml4 from "!!raw-loader!./sandpackFiles/4/index.html";
import engineTs4 from "!!raw-loader!./sandpackFiles/4/src/engine.ts";
import renderSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/renderSystem.ts";
import inputSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/inputSystem.ts";
import momentumSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/momentumSystem.ts";
import collisionSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/collisionSystem.ts";
import collisionLogSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/collisionLogSystem.ts";
import forEntsWithTs4 from "!!raw-loader!./sandpackFiles/4/src/forEntsWith.ts";
import entitiesTs4 from "!!raw-loader!./sandpackFiles/4/src/entities.ts";

import engineTs5 from "!!raw-loader!./sandpackFiles/5/src/engine.ts";
import renderSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/renderSystem.ts";
import inputSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/inputSystem.ts";
import momentumSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/momentumSystem.ts";
import collisionSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/collisionSystem.ts";
import reboundSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/reboundSystem.ts";
import forEntsWithTs5 from "!!raw-loader!./sandpackFiles/5/src/forEntsWith.ts";
import entitiesTs5 from "!!raw-loader!./sandpackFiles/5/src/entities.ts";

# Entity + Component + System

## A surprisingly simple way to build a universe

If you're looking for a programming project that's as far as possible from building a React app or a CRUD API, may I suggest handcrafting a tiny game engine and setting a universe in motion?

That's what I was after when I came across a handful of blog posts about the Entity-Component-System architecture (ECS). Internet people say that ECS makes games easy to extend in an open-ended, additive process. That sounds like my ideal of recreational programming. There are lots of ways to build an ECS, and lots of optimization tricks to make it work at scale. I made mine up as I went along and didn't do any optimization. In the end, without any particular planning, I ended up with something fun. The scale was tiny and I don't have any other gamedev experience to compare it to, but I think ECS delivered.

I'll demonstrate the core of the engine and then start adding game dynamics. By the end, I hope making your own tiny game engine seems both approachable and fun.

## The Concept

_Entities_ are just bags of properties. These properties are called _components_, and they change over time thanks to _systems_.

A system is concerned with one or more specific components. It looks at every entity with those components and makes some changes. At every tick of game time, each system takes its turn processing all of its relevant entities. Systems run in the same order every time.

Below, there are two entities, one using the `incrementSystem` and the other using that _and_ the `rotateSystem`. There's also a special `renderSystem`. Soon we'll switch these systems and components out, but the core loop won't change as we progress to a game with collision physics.

A couple notes about these code sandboxes: they're made with the incredible [Sandpack](https://sandpack.codesandbox.io/), and I'll often hide some files to keep focus on what's changing. You can always click "Open Sandbox" to see the full code.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml1,
    "/styles.css": styles1,
    "/index.ts": indexTs1,
    "/src/engine.ts": engineTs1,
    "/src/renderSystem.ts": renderSystemTs1,
    "/src/entities.ts":entitiesTs1,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
  visibleFiles: ["/src/engine.ts","/src/entities.ts", "/src/renderSystem.ts",],
  activeFile: "/src/engine.ts",
}}
/>

## Universe Input/Output

The `renderSystem` is an odd duck. It knows about non-gameworld things like the DOM (or, depending on our rendering target, the canvas API or even WebSockets). And we'll need another special system, `inputSystem`, to listen for keyboard events. I want to keep these these "impure" systems as self-contained as possible. This makes the game easier to test and more portable to other platforms.

Below, we've switched our rendering from div styling to canvas drawing and increased the framerate to ~30fps. The count and rotation properties are gone, replaced by the ones our game will actually use:

- `position`: Where is the entity in 2D space; where should we draw it?
- `appearance`: How does the entity look in terms of width, height and fill-color? This could later refer to a sprite or a 3D model.
- `playerControl`: Does the entity respond to keyboard input?

Notice how these components don't map 1-to-1 onto systems. `renderSystem` needs `position` and `appearance`, while `inputSystem` needs `playerControl` and `position`. Systems act as causal links between changing bits of state.

At this point you can click the canvas and use your arrow keys or WASD to move the red square.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml2,
    "/styles.css": styles2,
    "/index.ts": indexTs2,
    "/src/engine.ts": engineTs2,
    "/src/renderSystem.ts": renderSystemTs2,
    "/src/inputSystem.ts": inputSystemTs2,
    "/src/entities.ts": entitiesTs2,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/engine.ts", "/src/inputSystem.ts", "/src/renderSystem.ts", "/src/entities.ts"],
    activeFile: "/src/engine.ts",
  }}
/>

## Toy Physics

Already fun! But I wish the toy universe would do something when I'm not pressing buttons. Lets build a system to simulate momentum, with some friction so entities don't just fly away.

For the player entity to participate in the new dynamic, the `inputSystem` will stop setting location directly and instead affect velocity, a bit like a strong wind. The new `momentumSystem` will apply velocity to position, and then apply friction to velocity, so we need these new components:

- `velocity`: Rate of movement on both the X and the Y axis.
- `friction`: Decay rate for the velocity. This could be hardcoded in the momentum system, but extra friction on the player offers more control.

Students of _this_ universe might notice that all of these systems treat the velocity's X and Y aspect independently, so a diagonal movement will be faster than a cardinal one, and friction might bring an entity to a stop on one axis before the other, imparting a curved trajectory. The physics feel surprisingly nice despite this, so I'm calling it good enough.

You might also notice that when systems update components, they're mutating the entities in place, something to avoid in React land. This is a bit faster than creating new entities for every system at every tick, and saves on garbage-collection.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml2,
    "/styles.css": styles2,
    "/index.ts": indexTs2,
    "/src/engine.ts": engineTs3,
    "/src/renderSystem.ts": renderSystemTs3,
    "/src/inputSystem.ts": inputSystemTs3,
    "/src/momentumSystem.ts": momentumSystemTs3,
    "/src/entities.ts": entitiesTs3,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/momentumSystem.ts", "/src/inputSystem.ts", "/src/entities.ts"],
    activeFile: "/src/momentumSystem.ts",
  }}
/>

It's time to add collision-detection, which will be the basis of all interaction between entities. On my first pass I thought collision and rebound would be a single system, but what if we want game conditions triggered by an invisible box? Discovering collisions should be separate from reacting to them.

I'm used to thinking of collision as a broadcast event, like the browser's `mouseEnter`, but event APIs differ between the client and the server, so that's not portable. In any case, the event would have to be saved for other systems for an entire tick, likely as a component. A broadcast-free pattern emerges: the `collisionSystem` looks at entity edges and adds `collision` components to overlapping entities. Other systems can use these however they need to.

We'll have to compare edges between every collidable entity, so I've written a helper function, `forEntsWith`, to make this nested looping readable and type-safe. It provides a filtered list of collidable peers for each entity.

The first thing to do is clear any existing collision events from the previous tick. Because systems always run in the same order, we know that all the other systems have had a chance to read it already. Then we look at the new state of play. We compare the left, right, top, and bottom edges of every entity. If there's overlap on BOTH X and Y axes, we know they're occupying some of the same space, and we can add a collision to the `collisionBox` component. That will contain the following data:

- `xOverlap`: Overlap on the X axis.
- `yOverlap`: Overlap on the Y axis.
- `otherEntId`: The other driver's ID. This lets us get data for rebounds and more.

Below, I've provided a real-time display of the overlap data on the red player-controlled entity, which I've also made transparent.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml4,
    "/styles.css": styles2,
    "/index.ts": indexTs2,
    "/src/engine.ts": engineTs4,
    "/src/renderSystem.ts": renderSystemTs4,
    "/src/inputSystem.ts": inputSystemTs4,
    "/src/momentumSystem.ts": momentumSystemTs4,
    "/src/collisionSystem.ts": collisionSystemTs4,
    "/src/collisionLogSystem.ts": collisionLogSystemTs4,
    "/src/forEntsWith.ts": forEntsWithTs4,
    "/src/entities.ts": entitiesTs4,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/collisionSystem.ts", "/src/forEntsWith.ts", "/src/entities.ts"],
    activeFile: "/src/collisionSystem.ts",
  }}
/>

## ReboundSystem

I have to point out here that collisions are relatively easy to model here because everything is a rectangle and doesn't rotate. Assuming entities are perfectly elastic, we can model the rebound between moving entities as a trade of velocities. Some entities should also be immovable, like walls. If the other entity doesn't have a velocity component, we'll reverse the velocity of the moving entity on its axis of impact.

So we need to know the axis of the collision. As you explore collisions above, you'll see that the overlap with the smaller absolute value generally indicates the axis. That stops being true as the overlap becomes more complete, but hopefully our rebound system prevents this from happening!

By saving the value of the overlap, we can also cancel it out on impact. Entities overlapping for more than a single tick are a rich source of bugs in this model.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml2,
    "/styles.css": styles2,
    "/index.ts": indexTs2,
    "/src/engine.ts": engineTs5,
    "/src/renderSystem.ts": renderSystemTs5,
    "/src/inputSystem.ts": inputSystemTs5,
    "/src/momentumSystem.ts": momentumSystemTs5,
    "/src/collisionSystem.ts": collisionSystemTs5,
    "/src/reboundSystem.ts": reboundSystemTs5,
    "/src/forEntsWith.ts": forEntsWithTs5,
    "/src/entities.ts": entitiesTs5,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/collisionSystem.ts", "/src/reboundSystem.ts", "/src/entities.ts"],
    activeFile: "/src/collisionSystem.ts",
  }}
/>

export default function MDXPage({ children }) {
  return <MdxLayout>{children}</MdxLayout>;
}
import { collisionLogSystem } from "./sandpackFiles/4/src/collisionLogSystem";
