import { MdxLayout } from "../../components/MdxLayout";
import { ImageFull } from "../../components/ImageFull";
import { Sandbox } from "../../components/Sandbox";

import { styles as styles1 } from "./sandpackFiles/1/styles.ts";
import indexHtml1 from "!!raw-loader!./sandpackFiles/1/index.html";
import indexTs1 from "!!raw-loader!./sandpackFiles/1/index.ts";
import engineTs1 from "!!raw-loader!./sandpackFiles/1/src/engine.ts";
import renderSystemTs1 from "!!raw-loader!./sandpackFiles/1/src/renderSystem.ts";
import typesTs1 from "!!raw-loader!./sandpackFiles/1/src/types.ts";

import { styles as styles2 } from "./sandpackFiles/2/styles.ts";
import indexHtml2 from "!!raw-loader!./sandpackFiles/2/index.html";
import indexTs2 from "!!raw-loader!./sandpackFiles/2/index.ts";
import engineTs2 from "!!raw-loader!./sandpackFiles/2/src/engine.ts";
import renderSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/renderSystem.ts";
import inputSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/inputSystem.ts";
import typesTs2 from "!!raw-loader!./sandpackFiles/2/src/types.ts";

# Entity + Component + System

## A surprisingly simple way to build a universe

If you're looking for a programming project that's as far as possible from building a React app or a CRUD API, may I suggest handcrafting a tiny game engine and setting a universe in motion?

That's what I was after when I came across a handful of blog posts about the Entity-Component-System architecture (ECS). Internet people say that ECS makes games easy to extend in an open-ended, additive process. That sounds like my ideal of recreational programming. There are lots of ways to build an ECS, and lots of optimization tricks to make it work at scale. I made mine up as I went along and didn't do any optimization. In the end, without any particular planning, I ended up with something fun. The scale was tiny and I don't have any other gamedev experience to compare it to, but I think ECS delivered.

I'll demonstrate the core of the engine and then start adding game dynamics. By the end, I hope making your own tiny game engine seems both approachable and fun.

## The Concept

_Entities_ are just bags of properties. These properties are called _components_, and they change over time thanks to _systems_.

A system is concerned with one or more specific components. It looks at every entity with those components and makes some changes. At every tick of game time, each system takes its turn processing all of its relevant entities. Systems run in the same order every time.

Below, there are two entities, one using the `incrementSystem` and the other using that _and_ the `rotateSystem`. There's also a special `renderSystem`. We'll eventually switch these systems and components out, but this core logic will hardly change as we progress to a game with collision physics.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml1,
    "/styles.css": styles1,
    "/index.ts": indexTs1,
    "/src/engine.ts": engineTs1, 
    "/src/renderSystem.ts": renderSystemTs1,
    "/src/types.ts": typesTs1,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
  visibleFiles: ["/src/engine.ts", "/src/renderSystem.ts", "/src/types.ts"],
  activeFile: "/src/engine.ts",
}}
/>

## Universe Input/Output

The `renderSystem` is an odd duck. It knows about non-gameworld things like the DOM (or, depending on our rendering target, the canvas API or even WebSockets). And we'll need another special system, `inputSystem`, to listen for keyboard events. I want to keep these these "impure" systems as self-contained as possible. This makes the game easier to test and more portable to other platforms.

Below, we've added the first real components to our entities:

- `position`: Where is the entity in 2D space; where should we draw it?
- `appearance`: How does the entity look? We're just drawing rectangles with width, height and fill-color, but this could also refer to a sprite or a 3D model at some point.
- `playerControl`: Does the entity respond to keyboard input? A simple Boolean.

Notice how these components don't map 1-to-1 onto systems. `renderSystem` needs `position` and `appearance`, while `inputSystem` needs `playerControl` and `position`. This is a sign of decoupling between systems, meaning you can make big changes to one system without necessarily worrying about the others.

Click the canvas and use your arrow keys or WASD to move the red square around.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml2,
    "/styles.css": styles2,
    "/index.ts": indexTs2,
    "/src/engine.ts": engineTs2, 
    "/src/renderSystem.ts": renderSystemTs2,
    "/src/inputSystem.ts": inputSystemTs2,
    "/src/types.ts": typesTs2,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/engine.ts", "/src/renderSystem.ts", "/src/inputSystem.ts", "/src/types.ts"],
    activeFile: "/src/engine.ts",
  }}
/>

Already fun!

export default function MDXPage({ children }) {
  return <MdxLayout>{children}</MdxLayout>;
}
import { renderSystem } from "./sandpackFiles/1/src/renderSystem.ts";
import { inputSystem } from "./sandpackFiles/2/src/inputSystem";
import { render } from "react-dom";
