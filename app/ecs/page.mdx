import { MdxLayout } from "../../components/MdxLayout";
import { ImageFull } from "../../components/ImageFull";
import { Sandbox } from "../../components/Sandbox";

import { styles } from "./sandpackFiles/1/styles.ts";
import indexHtml from "!!raw-loader!./sandpackFiles/1/index.html";
import indexTs from "!!raw-loader!./sandpackFiles/1/index.ts";

import engineTs1 from "!!raw-loader!./sandpackFiles/1/src/engine.ts";
import entitiesTs1 from "!!raw-loader!./sandpackFiles/1/src/entities.ts";
import renderSystemTs1 from "!!raw-loader!./sandpackFiles/1/src/renderSystem.ts";
import momentumSystemTs1 from "!!raw-loader!./sandpackFiles/1/src/momentumSystem.ts";

import engineTs2 from "!!raw-loader!./sandpackFiles/2/src/engine.ts";
import entitiesTs2 from "!!raw-loader!./sandpackFiles/2/src/entities.ts";
import renderSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/renderSystem.ts";
import momentumSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/momentumSystem.ts";
import inputSystemTs2 from "!!raw-loader!./sandpackFiles/2/src/inputSystem.ts";

import indexHtml3 from "!!raw-loader!./sandpackFiles/3/index.html";
import engineTs3 from "!!raw-loader!./sandpackFiles/3/src/engine.ts";
import entitiesTs3 from "!!raw-loader!./sandpackFiles/3/src/entities.ts";
import renderSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/renderSystem.ts";
import inputSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/inputSystem.ts";
import momentumSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/momentumSystem.ts";
import collisionSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/collisionSystem.ts";
import collisionLogSystemTs3 from "!!raw-loader!./sandpackFiles/3/src/collisionLogSystem.ts";

import engineTs4 from "!!raw-loader!./sandpackFiles/4/src/engine.ts";
import renderSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/renderSystem.ts";
import inputSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/inputSystem.ts";
import momentumSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/momentumSystem.ts";
import collisionSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/collisionSystem.ts";
import reboundSystemTs4 from "!!raw-loader!./sandpackFiles/4/src/reboundSystem.ts";
import entitiesTs4 from "!!raw-loader!./sandpackFiles/4/src/entities.ts";

import engineTs5 from "!!raw-loader!./sandpackFiles/5/src/engine.ts";
import renderSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/renderSystem.ts";
import inputSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/inputSystem.ts";
import momentumSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/momentumSystem.ts";
import collisionSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/collisionSystem.ts";
import reboundSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/reboundSystem.ts";
import infectionSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/infectionSystem.ts";
import lurchSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/lurchSystem.ts";
import gameOverSystemTs5 from "!!raw-loader!./sandpackFiles/5/src/gameOverSystem.ts";
import utilsTs5 from "!!raw-loader!./sandpackFiles/5/src/utils.ts";
import entitiesTs5 from "!!raw-loader!./sandpackFiles/5/src/entities.ts";

# Entity + Component + System

## A surprisingly simple way to build a universe

If you're looking for a programming project that's as far as possible from building a React app, may I suggest handcrafting a tiny game engine and setting a universe in motion?

That's what I was after when I came across a handful of blog posts about the Entity-Component-System pattern, commonly known as ECS. First it was the [Starmancer devblog](https://www.playstarmancer.com/devblog/2018/9/25/component-system-same-face-new-engine), which didn't reference ECS directly but gave a feel for the pleasure of a radically extensible game engine. Then I found Maxwell Forbes' magisterial sequence on [building an ECS in Typescript](https://maxwellforbes.com/posts/typescript-ecs-what/).

Proponents say that ECS manages the complexity of interacting game dynamics by keeping them decoupled as single-responsibility systems. If you're less worried about what breaks when you add or edit a game dynamic, then you're closer to an open-ended, additive process – my ideal of recreational programming.

There are lots of ways to build an ECS, and lots of optimization tricks to make it work at scale. I made mine up as I went along and didn't do any optimization, but within that framework I noodled my way to something pretty fun without ever feeling like the complexity was getting out of hand.

## The Core

_Entities_ are just bags of data. These data are called _components_, and they store the state of the game. They change over time thanks to _systems_. A system is concerned with only a few components. It looks at every entity with those components and makes some changes. At every tick of game time, each system takes its turn processing its relevant entities.

I think this is a decent minimal definition of an ECS, but I'm not trying to be too rigorous here. My entities are simple objects whose properties I'm calling components.

One thing missing from my implementation is a way for systems to efficiently query for entities they should act on, a basic affordance of any real engine. I just rummage through the properties of all my entities. But I never encountered any performance issues at this tiny scale, so I couldn't bring myself to obscure the beautiful simplicity of the core loops.

A couple notes about these code sandboxes: they're made with the wonderful [Sandpack](https://sandpack.codesandbox.io/), and I'll often hide some files to keep focus on what's changing. You can always click "Open Sandbox" to see the full code.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml,
    "/styles.css": styles,
    "/index.ts": indexTs,

    "/src/engine.ts": engineTs1,
    "/src/entities.ts":entitiesTs1,
    "/src/renderSystem.ts": renderSystemTs1,
    "/src/momentumSystem.ts": momentumSystemTs1,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
  visibleFiles: ["/src/engine.ts","/src/entities.ts","/src/momentumSystem.ts", "/src/renderSystem.ts", ,],
  activeFile: "/src/engine.ts",
}}
/>

There are three entities above, using some combination of three components:

- `appearance`: How does the entity look in terms of width, height and fill-color?
- `position`: Where is the entity in 2D space; where should we draw it?
- `velocity`: How does its position change before the next tick?

The `momentumSystem` sees that Red and Green have position and velocity, so it updates their position by their velocity. Notice how there's not a 1-to-1 mapping of systems to components. Systems generally act as causal links _between_ bits of state.

## Universe Input/Output

The `renderSystem` is an odd one because it knows about non-gameworld things like the DOM and the canvas API.
Similarly, the `inputSystem` below is mainly code for translating keyboard events to player intent. As long as platform details are isolated to these systems, we should have an easy time writing tests for the other systems, and even porting the game to another platform like a Node server. There's something really satisfying in the isolation of these I/O systems, like I've built a terrarium and all I can do is look through the glass and tap on it.

The `inputSystem` only looks at entities with `velocity` and `playerControlled`, and updates their velocity based on keypresses, affecting them a bit like a strong wind. I've also updated the `momentumSystem` to look at the new `friction` component, which will slow down entities over time.

At this point you can click the canvas and use your arrow keys or WASD to move the red square.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml,
    "/styles.css": styles,
    "/index.ts": indexTs,

    "/src/engine.ts": engineTs2,
    "/src/entities.ts": entitiesTs2,
    "/src/renderSystem.ts": renderSystemTs2,
    "/src/momentumSystem.ts": momentumSystemTs2,
    "/src/inputSystem.ts": inputSystemTs2,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/engine.ts", "/src/inputSystem.ts", "/src/momentumSystem.ts", "/src/entities.ts"],
    activeFile: "/src/engine.ts",
  }}
/>

Already fun! Students of _this_ universe might notice that all of these systems treat the velocity's X and Y aspect independently, so a diagonal movement will be faster than a cardinal one, and friction might bring an entity to a stop on one axis before the other, imparting a curved path. The controls feel surprisingly nice despite this, so I'm calling it good enough.

## Collisions

Now it's time to add collision-detection, the basis of all interaction between entities in this game. On my first pass I thought collision and rebound would be a single system, but what if we want game conditions triggered by an invisible box? Discovering collisions should be separate from reacting to them.

I'm used to thinking of collision as a broadcast event, like the browser's `mouseEnter`, but event APIs differ between platforms, and in any case the event would have to be saved for other systems for an entire tick, likely as a component. A broadcast-free pattern emerges: the `collisionSystem` looks at entity edges and adds collison data to the `collisionBox` component of overlapping entities. Other systems can use these however they need to.

The first thing to do is clear any existing collision events from the previous tick. Because systems always run in the same order, we know that all the other systems have had a chance to see them already. Then we look at the new state of play. We compare the left, right, top, and bottom edges of every entity, and if there's overlap on both axes we know they're occupying some of the same space. Then we add a collision to the `collisionBox` component, containing the following data:

- `otherEntId`: The other driver's ID. This lets us get data for rebounds and more.
- `xOverlap`: Overlap on the X axis.
- `yOverlap`: Overlap on the Y axis.

I'm on the fence about whether the overlap values should be included there. The `collisionSystem` has the information handy just in proving a collision happened, and it would require more loops in another system to derive the same data. On the other hand, it's only used for rebounds (coming up soon) and strains the single-responsibility of `collisionSystem`.

Anywho, below I've included a real-time display of the overlap data on the red player-controlled entity:

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml3,
    "/styles.css": styles,
    "/index.ts": indexTs,

    "/src/engine.ts": engineTs3,
    "/src/renderSystem.ts": renderSystemTs3,
    "/src/inputSystem.ts": inputSystemTs3,
    "/src/momentumSystem.ts": momentumSystemTs3,
    "/src/collisionSystem.ts": collisionSystemTs3,
    "/src/collisionLogSystem.ts": collisionLogSystemTs3,
    "/src/entities.ts": entitiesTs3,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/collisionSystem.ts", "/src/entities.ts"],
    activeFile: "/src/collisionSystem.ts",
  }}
/>

## ReboundSystem

Not all entities should rebound. To make the rebound capacity explicit, I'll add a `rigidBody` component, with a nested property `stuck` to indicate that an entity is immovable, useful for walls. The `reboundSystem` will only act on entities with `rigidBody` components.

Collisions are relatively easy to model here because everything is a rectangle and doesn't rotate. Assuming entities are perfectly elastic, we can model the rebound between moving entities as a trade of velocities on the impact axis. If the other entity is stuck we reverse the moving entity's velocity on the impact axis instead.

So we need to know the axis of the collision. As you explore collisions above, you'll see that the overlap with the smaller absolute value generally indicates the axis. It's not a perfect heuristic – very fast entities could end up overlapping in any arrangement by the time the collision is detected – but it works well enough. The overlap value also lets us immediately move entities safely outside of collision bounds. Lots of buggy behavior just vanished when I figured this out.

There are a couple of interesting loops to notice in the reboundSystem. First of all, we're not applying the new position/velocity values as soon as we discover them. If we did, entities that get checked later in the `reboundSystem` wouldn't be responding to their counterpart's velocity at the time of impact, but to the velocity they themselves had imparted! So we collect all the updates and apply them in a second loop.

There's also a loop over multiple collisions accrued on a single entity, like when an entity runs directly into a corner formed by 2 walls. Though the collisions may be simultaneous, we can treat them sequentially: Wall-X reverses X velocity, then wall-Y reverses the Y velocity, and the entity flies back in the opposite direction.

It was a lot of work, but things are getting interesting in there. We can bounce other entities around and keep everything contained to the canvas with walls, which came practically for free.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml,
    "/styles.css": styles,
    "/index.ts": indexTs,

    "/src/engine.ts": engineTs4,
    "/src/renderSystem.ts": renderSystemTs4,
    "/src/inputSystem.ts": inputSystemTs4,
    "/src/momentumSystem.ts": momentumSystemTs4,
    "/src/collisionSystem.ts": collisionSystemTs4,
    "/src/reboundSystem.ts": reboundSystemTs4,
    "/src/entities.ts": entitiesTs4,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/reboundSystem.ts", "/src/collisionSystem.ts", "/src/entities.ts"],
    activeFile: "/src/reboundSystem.ts",
  }}
/>

## Win Condition

It's finally time to make the game winnable. Here's the setup: Three pink squares are hiding in a broom-closet while zombies lurch around outside. You win if you can bounce one of them into the yellow safe-zone. You lose if zombies get them all. You (red) are immune to zombies and can safely shove them.

Three new systems are needed here:

- `infectionSystem`: Convert pink squares to green on contact with zombies.
- `lurchSystem`: Give zombies a bit of random movement when they run out of momentum.
- `gameOverSystem`: Detect win/loss conditions and show a message. We'll update `appearance` and `renderSystem` with some _very_ basic text rendering to support this.

We'll also want some new components. We could handle all of the logic above using `appearance.color`, but better to be explicit.

- `infectious`: A flag to indicate a zombie.
- `infectable`: A flag to indicate that a square can become a zombie.
- `goal`: A flag to indicate the goal box.

We'll need a lot of entities for this, so I've added some utility functions to reduce boilerplate, `makeSquare` and `makeWall`.

<Sandbox
  template="vanilla-ts"
  files={{
    "/index.html": indexHtml,
    "/styles.css": styles,
    "/index.ts": indexTs,

    "/src/engine.ts": engineTs5,
    "/src/renderSystem.ts": renderSystemTs5,
    "/src/inputSystem.ts": inputSystemTs5,
    "/src/momentumSystem.ts": momentumSystemTs5,
    "/src/collisionSystem.ts": collisionSystemTs5,
    "/src/reboundSystem.ts": reboundSystemTs5,
    "/src/infectionSystem.ts": infectionSystemTs5,
    "/src/lurchSystem.ts": lurchSystemTs5,
    "/src/gameOverSystem.ts": gameOverSystemTs5,
    "/src/utils.ts": utilsTs5,
    "/src/entities.ts": entitiesTs5,
    "/package.json": `{
      "dependencies": {},
        "devDependencies": {
          "typescript": "^4.0.0"
        },
      "main": "/index.html"
    }`,
    "/sandbox.config.json": `{ "hardReloadOnChange" :  true }`,

}}
options={{
    visibleFiles: ["/src/infectionSystem.ts", "/src/gameOverSystem.ts", "/src/utils.ts", "/src/entities.ts"],
    activeFile: "/src/infectionSystem.ts",
    classes: {
      "sp-layout": "custom-layout",
    },
  }}
/>

export default function MDXPage({ children }) {
  return <MdxLayout>{children}</MdxLayout>;
}
